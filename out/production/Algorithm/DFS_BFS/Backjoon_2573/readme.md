# [[2573]빙산](https://www.acmicpc.net/problem/2573)

## DFS/BFS를 이용한 풀이

### 문제를 꼼꼼히 읽는 것이 중요하다.<br>

- 한 해동안 빙산이 녹는데 이때 **`주변의 바다가 있는 만큼`** 녹는다.
  
- **`배열의 첫 번째 행과 열, 마지막 행과 열에는 항상 0으로 채워진다.`**
  
  - 이말인즉슨, 빙산은 **무조건 녹는 경우만 주어진다**는 것이다.
    
-  각 칸에 들어가는 값은 0 이상 10 이하이다.
   
    - 각 칸에 들어가는 값은 10 이하이지만, 빙산이 녹는 시간은 10년 이상일 수 있다.
 
        ```java
        3 3
        0 0 0
        0 99 0
        0 0 0
        ```

<br>

### 빙산이 다 녹을 때까지 분리되지 않는 경우<br>

- 빙산의 양를 의미하는 `amount`를 사용한다.
- 만약 빙산이 다 녹았다면 `amount`는 0이 되므로 종료시킨다.
- 이때, 작년 빙산 개수인 `count`가 1인 상태(즉, 빙산이 한개로 아직 존재 = 계속 bfs 탐색을 할 수 있는 상태)여야 한다.
- 작년 빙산 개수가 2 이상이라면 작년이 종료 조건을 성립하므로, 작년을 최초 시간으로 리턴해주어야한다.

- 반례 주의 (amount)

```java
5 5
0 0 0 0 0
0 6 9 6 0
0 3 3 9 0
0 6 1 6 0
0 0 0 0 0
```

### BFS 탐색을 할 때 주의할 점<br>

- BFS 탐색을 하면서 해당 빙산의 영역을 체크해줌과 동시에 빙산이 녹아야한다.
- 하지만 영역 검사를 마치기 전가지 빙산이 녹으면 안된다.
- 따라서 덱에 해당 칸이 '0'을 가지는 경우를 카운트해주고 bfs 탐색이 완전히 끝난 시점에서 빙산을 녹여준다.
- 이때 총 빙산의 양인 `amount` 또한 같이 감소시켜주어야한다.

```java
while (!melt.isEmpty()) {
            int[] m = melt.pop();
            if (ice[m[0]][m[1]] > 0) {
                ice[m[0]][m[1]]--;
                amount--;
            }
        }
```