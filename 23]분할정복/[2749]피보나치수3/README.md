##### 입력 : 첫째 줄에 n이 주어진다. n은 1,000,000,000,000,000,000보다 작거나 같은 자연수이다.
##### ===> 1000
##### 출력 : 첫째 줄에 n번째 피보나치 수를 1,000,000으로 나눈 나머지를 출력한다.
##### ===> 228875

### code
    import sys; sys.setrecursionlimit(100000)
    n = int(input())
    dp = [-1] * (n+2)
    dp[1], dp[2] = 0, 1
    def fibo(m):
        if dp[m] != -1:
            return dp[m]
        dp[m] = (fibo(m-1)% 1000000)+(fibo(m-2)% 1000000)
        return dp[m]
    print(fibo(n+1))
##### 피보나치에 DP 적용하여 풀어봤으나 재귀함수 호출 깊이로 인한 런타임 오류가 발생
# Solution
### 피사노 주기
##### 피보나치 수를 k로 나눴을 때, 그 수는 일정한 주기를 가진다.  
###
##### k = 3 이라고 가정하였을 때, 피보나치의 피사노 주기 
n|1|2|3|4|5|6|7|8|9|10|11|12
---|---|---|---|---|---|---|---|---|---|---|---|---|
n mod 3|0|1|1|2|0|2|2|1|0|1|1|2
##### (x, y) 값이 다시 등장하는 n이 몇번째 인가? 
##### fibo(m+1) 이라고 한다면,
##### (0, 1) == (dp[m],dp[m+1]) 인 경우 m(ex. 9)부터 피사노 주기가 반복된다.
## 
##### EX) n이 m-1(ex. 8)보다 클 때,
##### fibo(n) == fibo(n%(m-1)) --> fibo(13) == fibo(13%8)=fibo(5)
### code
    n = int(input())
    dp = [-1, 0, 1]
    i=3
    while True:
        dp.append((dp[i - 1] + dp[i - 2]) % 1000000)
        if i<=n:
            if (0, 1) == (dp[i - 1], dp[i]):
                i -= 2      # 초기화되는 지점의 인덱스
                break
            i += 1
        else:
            break
    print(dp[n%i+1])    # index 주의!
 ##### 결과는 나오나, 시간이 오래 걸린다. (1000ms)
### short coding
##### 피보나치 수를 나눌 수를 K라고 할 때, k=10n 이면, 피사노 주기는 15∗10n−1이다.
    x, y = 1, 0
    for i in xrange(input()%1500000):
        x, y = y, (x+y)%1000000
    print t
